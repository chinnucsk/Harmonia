%% Sts : Exp | ( 'or' Exp)*
%% Exp : Factor ( 'and' Factor)*
%% Factor : Term ( '=='|'!='|'<='|'>='|'>'|'<'  Term|Number|String )*
%%         | '(' Sts ')'
%% Term : Tbl.Fld
%% Tbl : StringNum
%% Fld : StringNum
%% StringNum : 'a-Z' ('a-Z'|'0-9')*
%% 
%% examples:
%%     A and (B or C) and B or D => {'or' {'and' {'and' A {'or' B C}} B} D}
%                                   {'or',{'and',{'and',f1,{'or',f2,f3}},f4},f5}
%%     A or (B or C) and B or D => {'or' A {'or' {'and' {'or' B C} B} D}}
-module(hm_qp).
-compile([export_all]).

-define(CHARACTERS, "abcdefghijklmnopqrstuvwxyzABCDEFGHJKLMNOPQRSTUVWXYZ_").
-define(NUMBERS, "0123456789").
-define(RESERVED_WORDS, ["or","and"]).
-define(RELATIONAL_OPERATORS, ["<",">","==","!=","<=",">="]).
-define(PAREN, "()"]).

parse(Tokens) ->
    parse_sts(Tokens, []).

parse_sts([], Res) -> Res;
parse_sts(Tokens, []) ->
    case parse_exp(Tokens, []) of
        {number, Contents} -> {number, Contents};
        {identifier, Contents} -> {identifier, Contents};
        {Exp, Tokens2} ->
            case hd(Tokens2) of
                {or_op, _} -> {'or', Exp, parse_sts(tl(Tokens2), [])};
                _ -> {Exp, Tokens2}
            end;
        Exp -> Exp
    end.


parse_exp([], Res) -> Res;
parse_exp(Tokens, []) ->
    case parse_factor(Tokens, []) of
        {Factor, []} -> Factor;
        {Factor, Tokens2} ->
            case hd(Tokens2) of 
                {and_op, _} -> {'and', Factor, parse_exp(tl(Tokens2), [])};
                _ -> {Factor, Tokens2}
            end
    end.

parse_factor([Term|Tokens], []) -> {Term, Tokens}.



scan(Query)->
    scan(Query, [], []).

scan([],  Cur, Tokens) -> 
    lists:map(fun
                  ({identifier, String}) -> 
                      {identifier, lists:reverse(String)};
                  ({number, String}) -> 
                      {number, lists:reverse(String)};
                  ({Type, String}) -> 
                      {Type, String}
              end,
              Tokens++Cur);

scan(" " ++ Query, [], Tokens) ->
    scan(Query, [], Tokens);

scan(" " ++ Query, Cur, Tokens) ->
    scan(Query, [], Tokens++Cur);

scan("and" ++ Query, [], Tokens) ->
    scan(Query, [], Tokens++[{and_op, "and"}]);
scan("or" ++ Query, [], Tokens) ->
    scan(Query, [], Tokens++[{or_op, "or"}]);

scan(">=" ++ Query, Cur, Tokens) ->
    scan(Query, [], Tokens++Cur++[{relational_operator, ">="}]);
scan("<=" ++ Query, Cur, Tokens) ->
    scan(Query, [], Tokens++Cur++[{relational_operator, "<="}]);
scan("==" ++ Query, Cur, Tokens) ->
    scan(Query, [], Tokens++Cur++[{relational_operator, "=="}]);
scan("!=" ++ Query, Cur, Tokens) ->
    scan(Query, [], Tokens++Cur++[{relational_operator, "!="}]);
scan("<" ++ Query, Cur, Tokens) ->
    scan(Query, [], Tokens++Cur++[{relational_operator, "<"}]);
scan(">" ++ Query, Cur, Tokens) ->
    scan(Query, [], Tokens++Cur++[{relational_operator, ">"}]);

scan("." ++ Query, Cur, Tokens) ->
    scan(Query, [], Tokens++Cur++[{dot_op, "."}]);

scan("(" ++ Query, Cur, Tokens) ->
    scan(Query, [], Tokens++Cur++[{left_paren, "("}]);
scan(")" ++ Query, Cur, Tokens) ->
    scan(Query, [], Tokens++Cur++[{left_paren, ")"}]);

scan([Char|Query], [], Tokens) ->
    case char_type(Char) of 
        character ->
            scan(Query, [{identifier, [Char]}], Tokens);
        number ->
            scan(Query, [{number, [Char]}], Tokens);
        _ ->
            error
    end;

scan([Char|Query], [{identifier, String}], Tokens) ->
    scan(Query, [{identifier, [Char|String]}], Tokens);
scan([Char|Query], [{number, String}], Tokens) ->
    case char_type(Char) of 
        number ->
            scan(Query, [{number, [Char|String]}], Tokens);
        _ -> error
    end.

char_type(Char) ->
    case lists:member(Char, ?CHARACTERS) of 
        true -> character;
        false ->
            case lists:member(Char, ?NUMBERS) of 
                true -> number;
                false -> other_char
            end
    end.

eval({Op}) ->
    io:format("evaluating ~p ~n", [Op]),
    {result, Op};
eval({Rel, Op1, Op2}) ->
    Ret1 = eval(Op1),
    Ret2 = eval(Op2),
    io:format("evaluating ~p ~p ~p ==> ~p ~p ~p ~n", [Rel, Op1, Op2, Rel, Ret1, Ret2]),
    {result, Rel, Ret1, Ret2};
eval(Op) ->
    io:format("evaluating: ~p ~n", [Op]),
    {result, Op}.
    


Data Store Layer(harmonia_ds.erl)

    Description: This layer(module) has I/F with routing layer(harmonia.erl)
    
    store(Key, Value)
        Argments    : Key
                      Value
        Return Value: {ok, Cnt}
                      {ng, 0}
                      {partial, Cnt}
        Description : store data with key, and returns the status of result

    get(Key)
        Argments    : Key
        Return Value: Data
                      {error, nodata}
        Description : return data found first


    store(DomainName, TableName, Key, Value)
        Argments    : Key
                      Value
        Return Value: {ok, Cnt}
                      {ng, 0}
                      {partial, Cnt}
        Description : store data with key, and returns the status of result

    store(DomainName, TableName, KeyValueList)
        Argments    : KeyValueList::[{FldName, Value}]
                      FldName::string()
                      Value::any() in case of value field
                      Value::atom()|string() in case of key field
        Return Value: {ok, Cnt}
                      {ng, 0}
                      {partial, Cnt}
        Description : store data with key, and returns the status of result
                      if all field names in a table are not specified, the default value is set.
                      the fields spefified as 'Key' cannot be omitted.

    get(Key)
        Argments    : Key
        Return Value: Data
                      {error, nodata}
        Description : return data found first

Table Maintenance Layer(harmonia_tbl.erl)

    
    make_table(DomainName, TableName, Attributes)
        Argments    : DomainName::string()
                      TableName::string()
                      AttributeList::[{ColumnInfo}]
                      ColumnInfo::FieldName, KeyFlg, InitValue
                      FieldName::string()
                      KeyFlg::bool()
                      InitValue::any()

        Return Value: {ok, {NodeList::list(), FailedList::list()}}
        Description : make table definition on the node, and return the TableId
                      range query can be performed using fields that were specified as KeyFlg=true.
                      when KeyFlg=true, InitValue is true.
        Example     : harmonia_table:make_table("Domain1", "Tbl1", [{"Fld1",true, true},{"Fld2",false, []}]).


    get_table_info(DomanName, TableName)
        Argments    : DomainName::string()
                      TableName::string()
        Return Value: {ok, [{ColumnInfo}]}
                      ColumnInfo::FieldName, KeyFlg, InitValue
                      FieldName::string()
                      KeyFlg::bool()
                      InitValue::any()



Query Parser Layer(harmonia_query.erl)

    
    qp_make_table(DomainName, TableName, [{Attributes, Default}])
        Argments    : 
        Return Value: 
        Description : wrapper for making table definition on the node,
                      passing arguments to ds_make_table

    qp_store(DomainName, TableName, [{Attributes, Value}])
        Argments    : 
        Return Value: 
        Description : 

    qp_get(DomainName, TableName, Condition)
        Argments    : 
        Return Value: 
        Description : 

get(DomainName, TableName, CondList) ->
    {Op, Left, Right}

Tid = ets:new(tname,[public, duplicate_bag]).
ets:insert(Tid, {foo, [{fld1,xxx},{fld2,yyy}]}).
ets:insert(Tid, {foo, [{fld1,kkk},{fld2,vvv}]}).
ets:select(Tid, [{{'$1','$2'},[],['$$']}]).

ets:select(Tid, [{ {foo,[{'$1','$2'},{'$3','$4'}]}, [{'==', '$2', xxx}], ['$$']}]).
ets:select(Tid, 
[{{foo,[{'$1','$2'},{'$3','$4'}]}, [{'==', '$2', '$4'}], ['$$']},
{{foo,[{'$1','$2'},{'$3','$4'}]}, [{'==', '$2', xxx}], ['$$']}]).

32> ets:fun2ms(fun({A,B}) when (A > X; A == 100) -> B end).
[{{'$1','$2'},[{'>','$1',{const,25}}],['$2']},
 {{'$1','$2'},[{'==','$1',100}],['$2']}]

make list from query statement.
10> hm_qp:parse(hm_qp:scan("Fld2 == yyy")).            
{term,{relational_operator,{relational_operator,"=="}},
      {string,"Fld2"},
      {string,"yyy"}}
56> ets:fun2ms(fun({A,B}) when ((A > X) and (A == xxx)) or (A == 100) -> {A,B} end).
[{{'$1','$2'},
  [{'or',{'and',{'>','$1',{const,25}},{'==','$1',xxx}},
         {'==','$1',100}}],
  [{{'$1','$2'}}]}]


> hm_qp:parse(hm_qp:scan("Fld2 == yyy", [Fld1,Fld2,Fld3...])).
{'==', '$2', yyy}

1. in the scan, replace all fields names with '$1', '$2', '$3', etc...
2. in the parser, generate terms from query conditions, ex:
    {'==', '$2', yyy}
    {'>', '$2', 3}
    {'==', '$2', '$3'}
3. 多分、あとは同じ。ほとんど変更しなくてもよいと思う。










hm_qp:eval(hm_qp:parse(hm_qp:scan("Tble1.Fld1 == xxx and Tble1.Fld2 == yyy"))).

